---
phase: 02-backend-core
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified: [packages/backend/package.json, packages/backend/src/ws/index.ts, packages/backend/src/ws/handlers.ts, packages/backend/src/ws/types.ts, packages/backend/src/index.ts, packages/shared/src/types/ws-messages.ts, packages/shared/src/index.ts]
autonomous: true
---

<objective>
Set up WebSocket server for real-time communication between mobile app and backend.

Purpose: Enable real-time location updates between family members - the core feature of Draugar.
Output: Working WebSocket server integrated with Express, ready for location broadcasting.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-backend-core/02-01-PLAN.md

@packages/backend/src/index.ts
@packages/backend/package.json
@packages/shared/src/types/location.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Socket.IO and define message types</name>
  <files>packages/backend/package.json, packages/shared/src/types/ws-messages.ts, packages/shared/src/index.ts</files>
  <action>
Install Socket.IO (not raw ws - Socket.IO handles reconnection, rooms, and mobile-friendly transport fallbacks):

```bash
cd packages/backend
pnpm add socket.io
pnpm add -D @types/socket.io  # if needed (socket.io has built-in types now)
```

**packages/shared/src/types/ws-messages.ts:**
Define typed message contracts for client-server communication:

```typescript
import type { Location } from './location';

// Client -> Server messages
export interface ClientToServerEvents {
  'location:update': (location: Omit<Location, 'userId'>) => void;
  'location:subscribe': () => void;
  'location:unsubscribe': () => void;
}

// Server -> Client messages
export interface ServerToClientEvents {
  'location:broadcast': (location: Location) => void;
  'user:online': (userId: string) => void;
  'user:offline': (userId: string) => void;
  'error': (message: string) => void;
}

// Inter-server events (if using multiple servers later)
export interface InterServerEvents {}

// Socket data (attached to each socket)
export interface SocketData {
  userId: string | null;
  authenticated: boolean;
}
```

**packages/shared/src/index.ts:**
Export the new WebSocket message types.

Use Socket.IO's typed events pattern - this gives type safety on both client and server.
  </action>
  <verify>pnpm typecheck passes in packages/shared and packages/backend</verify>
  <done>Socket.IO installed. WebSocket message types defined in shared package.</done>
</task>

<task type="auto">
  <name>Task 2: Create WebSocket server module</name>
  <files>packages/backend/src/ws/index.ts, packages/backend/src/ws/handlers.ts, packages/backend/src/ws/types.ts</files>
  <action>
Create WebSocket server infrastructure:

**packages/backend/src/ws/types.ts:**
Re-export shared types and create server-specific socket type:
```typescript
import { Server, Socket } from 'socket.io';
import type {
  ClientToServerEvents,
  ServerToClientEvents,
  InterServerEvents,
  SocketData
} from '@draugar/shared';

export type DraugarServer = Server<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData>;
export type DraugarSocket = Socket<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData>;
```

**packages/backend/src/ws/handlers.ts:**
Create event handlers (placeholder implementations for now):
```typescript
import type { DraugarSocket } from './types';

export function handleLocationUpdate(socket: DraugarSocket, location: {...}) {
  // Will broadcast to family group after auth is implemented
  console.log(`[ws] Location update from socket ${socket.id}:`, location);
  // For now, echo back to sender as proof of concept
  socket.emit('location:broadcast', {
    ...location,
    userId: socket.data.userId || 'anonymous',
  });
}

export function handleSubscribe(socket: DraugarSocket) {
  console.log(`[ws] Socket ${socket.id} subscribed to location updates`);
  // Will join room based on family group after auth
}

export function handleUnsubscribe(socket: DraugarSocket) {
  console.log(`[ws] Socket ${socket.id} unsubscribed from location updates`);
}
```

**packages/backend/src/ws/index.ts:**
Initialize and configure Socket.IO server:
```typescript
import { Server as HttpServer } from 'http';
import { Server } from 'socket.io';
import type { DraugarServer, DraugarSocket } from './types';
import { handleLocationUpdate, handleSubscribe, handleUnsubscribe } from './handlers';

export function createWebSocketServer(httpServer: HttpServer): DraugarServer {
  const io: DraugarServer = new Server(httpServer, {
    cors: {
      origin: '*', // Will restrict in production
      methods: ['GET', 'POST'],
    },
  });

  io.on('connection', (socket: DraugarSocket) => {
    console.log(`[ws] Client connected: ${socket.id}`);

    // Initialize socket data
    socket.data.userId = null;
    socket.data.authenticated = false;

    // Register event handlers
    socket.on('location:update', (location) => handleLocationUpdate(socket, location));
    socket.on('location:subscribe', () => handleSubscribe(socket));
    socket.on('location:unsubscribe', () => handleUnsubscribe(socket));

    socket.on('disconnect', (reason) => {
      console.log(`[ws] Client disconnected: ${socket.id} (${reason})`);
    });
  });

  return io;
}

export type { DraugarServer, DraugarSocket };
```
  </action>
  <verify>pnpm typecheck passes in packages/backend</verify>
  <done>WebSocket server module created with typed events and handlers</done>
</task>

<task type="auto">
  <name>Task 3: Integrate WebSocket server with Express</name>
  <files>packages/backend/src/index.ts</files>
  <action>
Modify index.ts to create HTTP server and attach WebSocket:

1. Import `createServer` from 'http'
2. Import `createWebSocketServer` from './ws'
3. Create HTTP server wrapping Express app: `const server = createServer(app)`
4. Create WebSocket server: `const io = createWebSocketServer(server)`
5. Change `app.listen()` to `server.listen()`
6. Add `/api/ws-status` endpoint returning connection count: `{ connections: io.engine.clientsCount }`

The structure should be:
```typescript
import { createServer } from 'http';
import { createWebSocketServer } from './ws';

const app = express();
const server = createServer(app);
const io = createWebSocketServer(server);

// ... middleware and routes ...

server.listen(PORT, () => {
  console.log(`[backend] Server running on http://localhost:${PORT}`);
  console.log(`[backend] WebSocket ready on ws://localhost:${PORT}`);
});
```

This allows both HTTP and WebSocket on same port - important for mobile clients.
  </action>
  <verify>Server starts, connects via WebSocket client test</verify>
  <done>Express and WebSocket server integrated on same port. /api/ws-status shows connection count.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm typecheck` passes in packages/backend and packages/shared
- [ ] Server starts without errors
- [ ] `curl http://localhost:3001/api/ws-status` returns { connections: 0 }
- [ ] WebSocket types exported from @draugar/shared
- [ ] Console shows connection/disconnection logs when WebSocket client connects
</verification>

<success_criteria>
- All tasks completed
- Socket.IO installed and configured
- WebSocket message types shared between client and server
- WebSocket server runs on same port as HTTP
- Event handlers in place (placeholder implementations)
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-backend-core/02-03-SUMMARY.md`
</output>
