---
phase: 02-backend-core
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified: [packages/backend/src/index.ts, packages/backend/src/routes/index.ts, packages/backend/src/routes/health.ts, packages/backend/src/routes/users.ts, packages/backend/src/middleware/errorHandler.ts, packages/backend/src/middleware/requestLogger.ts, packages/backend/src/utils/ApiError.ts]
autonomous: true
---

<objective>
Set up Express API structure with proper routing, error handling, and middleware.

Purpose: Establish a clean, maintainable API architecture that handles errors gracefully and provides consistent response formats.
Output: Organized route structure with centralized error handling, ready for feature development.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-backend-core/02-01-PLAN.md

@packages/backend/src/index.ts
@packages/backend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API error handling utilities</name>
  <files>packages/backend/src/utils/ApiError.ts, packages/backend/src/middleware/errorHandler.ts</files>
  <action>
Create custom error class and centralized error handling middleware:

**packages/backend/src/utils/ApiError.ts:**
```typescript
export class ApiError extends Error {
  statusCode: number;
  isOperational: boolean;

  constructor(statusCode: number, message: string, isOperational = true) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    Error.captureStackTrace(this, this.constructor);
  }

  static badRequest(message: string) { return new ApiError(400, message); }
  static unauthorized(message: string) { return new ApiError(401, message); }
  static forbidden(message: string) { return new ApiError(403, message); }
  static notFound(message: string) { return new ApiError(404, message); }
  static internal(message: string) { return new ApiError(500, message, false); }
}
```

**packages/backend/src/middleware/errorHandler.ts:**
Express error handling middleware that:
- Catches ApiError instances and returns appropriate status/message
- Catches unknown errors and returns 500 with generic message in production
- Logs errors in development with stack trace
- Returns consistent JSON: { error: true, message: string, statusCode: number }
- Must be 4-arg function (err, req, res, next) to be recognized as error handler
  </action>
  <verify>pnpm typecheck passes in packages/backend</verify>
  <done>ApiError class and errorHandler middleware created and exported</done>
</task>

<task type="auto">
  <name>Task 2: Create request logging middleware</name>
  <files>packages/backend/src/middleware/requestLogger.ts</files>
  <action>
Create simple request logging middleware:

**packages/backend/src/middleware/requestLogger.ts:**
Log each request with: method, path, response time, status code.
Format: `[timestamp] METHOD /path - statusCode - Xms`

Keep it simple - no external logging library needed yet. Use console.log with colored output for development.

Export a middleware function that:
1. Records start time
2. Attaches to res.on('finish') to log when response completes
3. Logs method, originalUrl, statusCode, duration
  </action>
  <verify>pnpm typecheck passes in packages/backend</verify>
  <done>Request logger middleware created and exported</done>
</task>

<task type="auto">
  <name>Task 3: Set up route structure and refactor index.ts</name>
  <files>packages/backend/src/routes/index.ts, packages/backend/src/routes/health.ts, packages/backend/src/routes/users.ts, packages/backend/src/index.ts</files>
  <action>
Create organized route structure:

**packages/backend/src/routes/health.ts:**
Move health endpoint from index.ts to its own router.
```typescript
import { Router } from 'express';
const router = Router();
router.get('/', (req, res) => { res.json({ status: 'ok', timestamp: new Date().toISOString() }); });
export default router;
```

**packages/backend/src/routes/users.ts:**
Placeholder user routes (will be implemented with auth later):
```typescript
import { Router } from 'express';
import { ApiError } from '../utils/ApiError';
const router = Router();
// GET /users - list users (placeholder)
router.get('/', (req, res) => { res.json({ users: [] }); });
// GET /users/:id - get user (placeholder, demonstrates error handling)
router.get('/:id', (req, res, next) => {
  // Will query DB once auth is implemented
  next(ApiError.notFound(`User ${req.params.id} not found`));
});
export default router;
```

**packages/backend/src/routes/index.ts:**
Combine all routers:
```typescript
import { Router } from 'express';
import healthRouter from './health';
import usersRouter from './users';
const router = Router();
router.use('/health', healthRouter);
router.use('/users', usersRouter);
export default router;
```

**packages/backend/src/index.ts:**
Refactor to use new structure:
- Import routes from './routes'
- Import requestLogger from './middleware/requestLogger'
- Import errorHandler from './middleware/errorHandler'
- Remove inline health endpoint
- Remove type check code (no longer needed)
- Apply middleware: app.use(requestLogger), app.use('/api', routes), app.use(errorHandler)
- Keep cors() middleware (add cors package if not present)
  </action>
  <verify>curl http://localhost:3001/api/health returns { status: 'ok', ... }</verify>
  <done>Routes organized under /api prefix. Health at /api/health. Error handling works.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm typecheck` passes in packages/backend
- [ ] Server starts without errors
- [ ] `curl http://localhost:3001/api/health` returns JSON with status: ok
- [ ] `curl http://localhost:3001/api/users/nonexistent` returns 404 error JSON
- [ ] Request logging shows in console
</verification>

<success_criteria>
- All tasks completed
- Error handling middleware catches and formats errors
- Routes organized in /routes directory
- All endpoints prefixed with /api
- Request logging shows method, path, status, duration
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-backend-core/02-02-SUMMARY.md`
</output>
