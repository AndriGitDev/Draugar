---
phase: 06-mobile-polish-deployment
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/backend/Dockerfile
  - docker-compose.yml
  - .env.example
autonomous: true
---

<objective>
Dockerize backend for deployment to Finland VPS.

Purpose: Package backend as Docker container for easy deployment alongside existing Jellyseer setup.
Output: Dockerfile, docker-compose.yml, environment template.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@packages/backend/package.json
@packages/backend/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Dockerfile for backend</name>
  <files>packages/backend/Dockerfile</files>
  <action>
  Create multi-stage Dockerfile:

  Stage 1 (builder):
  - FROM node:20-alpine AS builder
  - Install pnpm globally
  - Copy root package.json, pnpm-lock.yaml, pnpm-workspace.yaml
  - Copy packages/shared and packages/backend
  - Run pnpm install --frozen-lockfile
  - Run pnpm --filter @draugar/backend build

  Stage 2 (runtime):
  - FROM node:20-alpine
  - Create non-root user (node)
  - Copy built dist from builder
  - Copy node_modules from builder (or install prod only)
  - EXPOSE 3000
  - HEALTHCHECK using /health endpoint
  - CMD ["node", "dist/index.js"]

  Key points:
  - Use alpine for small image
  - Multi-stage to exclude dev dependencies and source
  - Non-root user for security
  - Health check for container orchestration
  </action>
  <verify>Build image: cd packages/backend && docker build -t draugar-backend .</verify>
  <done>Dockerfile builds successfully, produces working image</done>
</task>

<task type="auto">
  <name>Task 2: Create docker-compose.yml for full stack</name>
  <files>docker-compose.yml, .env.example</files>
  <action>
  1. Create docker-compose.yml in project root:

  services:
    backend:
      build: ./packages/backend
      ports: ["3000:3000"]
      environment from .env
      depends_on: [db]
      restart: unless-stopped
      healthcheck using /health

    db:
      image: postgres:16-alpine
      volumes: [postgres_data:/var/lib/postgresql/data]
      environment: POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB
      restart: unless-stopped
      healthcheck using pg_isready

  volumes:
    postgres_data:

  2. Create .env.example with all required variables:
     - DATABASE_URL=postgresql://user:pass@db:5432/draugar
     - JWT_SECRET=generate-a-secure-secret-here
     - PORT=3000
     - NODE_ENV=production

  Key points:
  - Backend waits for db to be healthy
  - Persistent volume for PostgreSQL data
  - All secrets via environment variables
  - Internal Docker network (db not exposed externally)
  </action>
  <verify>Run: docker compose config (validates compose file syntax)</verify>
  <done>docker-compose.yml and .env.example exist, compose config validates</done>
</task>

<task type="auto">
  <name>Task 3: Test full stack with Docker Compose</name>
  <files>packages/backend/src/index.ts</files>
  <action>
  1. Create .env from .env.example with test values
  2. Run: docker compose up --build
  3. Wait for services to be healthy
  4. Test health endpoint: curl http://localhost:3000/health
  5. Verify PostgreSQL connection works (backend logs)

  If backend fails to connect to db:
  - Check DATABASE_URL uses 'db' hostname (Docker network)
  - Ensure db healthcheck passes before backend starts

  Document any issues found and fixes applied.

  Clean up: docker compose down -v (removes volumes for fresh test)
  </action>
  <verify>curl http://localhost:3000/health returns {"status":"ok"}</verify>
  <done>Full stack runs via docker compose, health check passes, backend connects to PostgreSQL</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Dockerfile builds without errors
- [ ] docker-compose.yml validates (docker compose config)
- [ ] .env.example documents all required variables
- [ ] `docker compose up --build` starts both services
- [ ] Health check passes: curl localhost:3000/health
- [ ] Backend logs show successful database connection
</verification>

<success_criteria>
- All tasks completed
- Backend containerized and runnable via Docker
- PostgreSQL included in compose stack
- Environment variables documented
- Health checks configured for both services
</success_criteria>

<output>
After completion, create `.planning/phases/06-mobile-polish-deployment/06-03-SUMMARY.md`
</output>
