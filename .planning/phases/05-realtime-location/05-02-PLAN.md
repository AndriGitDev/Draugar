---
phase: 05-realtime-location
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - packages/mobile/src/services/location/backgroundTask.ts
  - packages/mobile/src/services/location/locationService.ts
  - packages/mobile/src/services/location/index.ts
  - packages/mobile/App.tsx
autonomous: true
---

<objective>
Implement background location tracking service with expo-location and expo-task-manager.

Purpose: Enable continuous location tracking in background for family location sharing.
Output: Location service with permission handling, background task, start/stop controls.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-realtime-location/05-RESEARCH.md

@packages/mobile/src/crypto/location.ts
@packages/mobile/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create background location task</name>
  <files>packages/mobile/src/services/location/backgroundTask.ts</files>
  <action>
Create packages/mobile/src/services/location/ directory if not exists.

Create backgroundTask.ts that defines the TaskManager task. CRITICAL: This must be imported at app entry point (before any components render).

```typescript
import * as TaskManager from 'expo-task-manager';
import * as Location from 'expo-location';

export const LOCATION_TASK_NAME = 'draugar-background-location';

// This will be set by locationService when it starts
let onLocationUpdate: ((location: Location.LocationObject) => void) | null = null;

export function setLocationUpdateHandler(
  handler: ((location: Location.LocationObject) => void) | null
): void {
  onLocationUpdate = handler;
}

TaskManager.defineTask(LOCATION_TASK_NAME, async ({ data, error }) => {
  if (error) {
    console.error('[location] Background task error:', error.message);
    return;
  }

  if (data) {
    const { locations } = data as { locations: Location.LocationObject[] };
    if (locations.length > 0 && onLocationUpdate) {
      // Process most recent location
      onLocationUpdate(locations[locations.length - 1]);
    }
  }
});
```

Export LOCATION_TASK_NAME and setLocationUpdateHandler.
  </action>
  <verify>File exists at packages/mobile/src/services/location/backgroundTask.ts with TaskManager.defineTask call</verify>
  <done>Background task defined with handler registration pattern</done>
</task>

<task type="auto">
  <name>Task 2: Create location service with permission flow</name>
  <files>packages/mobile/src/services/location/locationService.ts</files>
  <action>
Create locationService.ts with:

1. requestLocationPermissions() - Request foreground first, then background (iOS requires this order)
2. startLocationUpdates(onUpdate) - Start tracking with battery-optimized settings
3. stopLocationUpdates() - Stop tracking
4. getLocationPermissionStatus() - Check current permission state

Use settings from RESEARCH.md:
- accuracy: Location.Accuracy.Balanced (not High - battery concern)
- distanceInterval: 50 meters
- deferredUpdatesInterval: 60000 (1 minute batching when backgrounded)
- pausesUpdatesAutomatically: true (iOS: pause when stationary)
- foregroundService notification for Android

```typescript
import * as Location from 'expo-location';
import { LOCATION_TASK_NAME, setLocationUpdateHandler } from './backgroundTask';

export interface LocationPermissions {
  foreground: boolean;
  background: boolean;
}

export async function getLocationPermissionStatus(): Promise<LocationPermissions> {
  const { status: foreground } = await Location.getForegroundPermissionsAsync();
  const { status: background } = await Location.getBackgroundPermissionsAsync();
  return {
    foreground: foreground === 'granted',
    background: background === 'granted',
  };
}

export async function requestLocationPermissions(): Promise<LocationPermissions> {
  // Foreground first (required before background on iOS)
  const { status: foreground } = await Location.requestForegroundPermissionsAsync();
  if (foreground !== 'granted') {
    return { foreground: false, background: false };
  }

  // Then background
  const { status: background } = await Location.requestBackgroundPermissionsAsync();
  return {
    foreground: true,
    background: background === 'granted',
  };
}

export async function startLocationUpdates(
  onUpdate: (location: Location.LocationObject) => void
): Promise<boolean> {
  const permissions = await getLocationPermissionStatus();
  if (!permissions.foreground) {
    console.error('[location] No foreground permission');
    return false;
  }

  // Register the update handler
  setLocationUpdateHandler(onUpdate);

  if (permissions.background) {
    // Check if already running
    const isRunning = await Location.hasStartedLocationUpdatesAsync(LOCATION_TASK_NAME);
    if (!isRunning) {
      await Location.startLocationUpdatesAsync(LOCATION_TASK_NAME, {
        accuracy: Location.Accuracy.Balanced,
        distanceInterval: 50,
        deferredUpdatesInterval: 60000,
        pausesUpdatesAutomatically: true,
        activityType: Location.ActivityType.Other,
        showsBackgroundLocationIndicator: true,
        foregroundService: {
          notificationTitle: 'Draugar',
          notificationBody: 'Sharing location with family',
          notificationColor: '#4A90A4',
        },
      });
    }
    console.log('[location] Background tracking started');
  } else {
    // Foreground-only fallback
    console.log('[location] Foreground-only tracking (no background permission)');
  }

  return true;
}

export async function stopLocationUpdates(): Promise<void> {
  setLocationUpdateHandler(null);

  const isRunning = await Location.hasStartedLocationUpdatesAsync(LOCATION_TASK_NAME);
  if (isRunning) {
    await Location.stopLocationUpdatesAsync(LOCATION_TASK_NAME);
  }
  console.log('[location] Tracking stopped');
}
```
  </action>
  <verify>File exists with all four exported functions: getLocationPermissionStatus, requestLocationPermissions, startLocationUpdates, stopLocationUpdates</verify>
  <done>Location service handles permissions and background tracking with battery-optimized settings</done>
</task>

<task type="auto">
  <name>Task 3: Create location service barrel export and import at app entry</name>
  <files>packages/mobile/src/services/location/index.ts, packages/mobile/App.tsx</files>
  <action>
1. Create packages/mobile/src/services/location/index.ts:

```typescript
// CRITICAL: Import backgroundTask first to register TaskManager task
import './backgroundTask';

export { LOCATION_TASK_NAME, setLocationUpdateHandler } from './backgroundTask';
export {
  requestLocationPermissions,
  startLocationUpdates,
  stopLocationUpdates,
  getLocationPermissionStatus,
  type LocationPermissions,
} from './locationService';
```

2. In App.tsx, add import at the TOP of the file (before other imports if possible, or right after React):

```typescript
// Must import before any component renders to register background task
import './src/services/location';
```

This ensures TaskManager.defineTask is called before the app tries to use background location.
  </action>
  <verify>
1. packages/mobile/src/services/location/index.ts exists and imports ./backgroundTask first
2. packages/mobile/App.tsx has import for ./src/services/location near the top
  </verify>
  <done>Background task registered at app startup, location service exports available</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] packages/mobile/src/services/location/backgroundTask.ts exists with TaskManager.defineTask
- [ ] packages/mobile/src/services/location/locationService.ts has all four functions
- [ ] packages/mobile/src/services/location/index.ts imports backgroundTask first
- [ ] packages/mobile/App.tsx imports ./src/services/location
- [ ] TypeScript compiles without errors: cd packages/mobile && npx tsc --noEmit
</verification>

<success_criteria>
- All tasks completed
- Background task registered at app startup
- Location service ready for use by map screen and socket integration
- Permission flow handles iOS foreground-first requirement
</success_criteria>

<output>
After completion, create `.planning/phases/05-realtime-location/05-02-SUMMARY.md`
</output>
