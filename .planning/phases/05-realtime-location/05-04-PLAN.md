---
phase: 05-realtime-location
plan: 04
type: execute
wave: 3
depends_on: ["05-02", "05-03"]
files_modified:
  - packages/shared/src/types/ws-messages.ts
  - packages/backend/src/ws/handlers.ts
  - packages/mobile/src/services/socket/index.ts
  - packages/mobile/src/screens/MapScreen.tsx
  - packages/mobile/src/context/LocationContext.tsx
autonomous: false
---

<objective>
Integrate encrypted location broadcasting via Socket.IO with family marker display on map.

Purpose: Complete the real-time location sharing loop - mobile broadcasts encrypted location, server relays to family, map displays all members.
Output: Working end-to-end encrypted location sharing with live map updates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-realtime-location/05-RESEARCH.md
@.planning/phases/02-backend-core/02-03-SUMMARY.md
@.planning/phases/04-e2e-encryption/04-04-SUMMARY.md

@packages/shared/src/types/ws-messages.ts
@packages/shared/src/types/crypto.ts
@packages/backend/src/ws/handlers.ts
@packages/mobile/src/crypto/location.ts
@packages/mobile/src/services/location/locationService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update WebSocket types for encrypted location</name>
  <files>packages/shared/src/types/ws-messages.ts</files>
  <action>
Update ws-messages.ts to use EncryptedPayload for location data instead of plain Location:

```typescript
import type { EncryptedPayload } from './crypto';

// Client -> Server messages
export interface ClientToServerEvents {
  // Location update contains encrypted payload (userId is in JWT auth, not payload)
  'location:update': (payload: EncryptedPayload) => void;
  'location:subscribe': () => void;
  'location:unsubscribe': () => void;
}

// Server -> Client messages
export interface ServerToClientEvents {
  // Broadcast includes senderId so receiver knows who sent it
  'location:broadcast': (data: { senderId: string; payload: EncryptedPayload }) => void;
  'user:online': (userId: string) => void;
  'user:offline': (userId: string) => void;
  'error': (message: string) => void;
}

// Keep existing InterServerEvents and SocketData unchanged
```

Note: The server does NOT decrypt - it just relays encrypted payloads. Zero-knowledge architecture.
  </action>
  <verify>grep "EncryptedPayload" packages/shared/src/types/ws-messages.ts shows import and usage in both events</verify>
  <done>WebSocket types use EncryptedPayload for location data</done>
</task>

<task type="auto">
  <name>Task 2: Update backend WebSocket handler for location relay</name>
  <files>packages/backend/src/ws/handlers.ts</files>
  <action>
Update handlers.ts to relay encrypted location to all authenticated users in the same group.

The server cannot decrypt - it just broadcasts to other family members.

```typescript
import type { EncryptedPayload } from '@draugar/shared';
import type { DraugarSocket, DraugarServer } from './types';

export function handleLocationUpdate(
  io: DraugarServer,
  socket: DraugarSocket,
  payload: EncryptedPayload
): void {
  const senderId = socket.data.userId;

  if (!senderId || !socket.data.authenticated) {
    socket.emit('error', 'Not authenticated');
    return;
  }

  // Broadcast to all OTHER authenticated sockets
  // In future: filter by group membership from database
  // For now: broadcast to all authenticated users (single family group)
  socket.broadcast.emit('location:broadcast', {
    senderId,
    payload,
  });

  console.log(`[ws] Location broadcast from user ${senderId}`);
}

// Keep handleSubscribe and handleUnsubscribe - they'll be used for room-based filtering later
export function handleSubscribe(socket: DraugarSocket): void {
  console.log(`[ws] Socket ${socket.id} subscribed to location updates`);
  // TODO: Join room based on group membership
}

export function handleUnsubscribe(socket: DraugarSocket): void {
  console.log(`[ws] Socket ${socket.id} unsubscribed from location updates`);
  // TODO: Leave room
}
```

Also update the main ws/index.ts to pass `io` to handleLocationUpdate:

```typescript
socket.on('location:update', (payload) => handleLocationUpdate(io, socket, payload));
```
  </action>
  <verify>grep "socket.broadcast.emit" packages/backend/src/ws/handlers.ts shows location broadcast</verify>
  <done>Backend relays encrypted location to other authenticated users</done>
</task>

<task type="auto">
  <name>Task 3: Create mobile Socket.IO service with location integration</name>
  <files>packages/mobile/src/services/socket/index.ts</files>
  <action>
Create packages/mobile/src/services/socket/ directory.

Create socket service that:
1. Connects to backend with JWT auth
2. Sends encrypted location updates
3. Receives and decrypts family location broadcasts

```typescript
import { io, Socket } from 'socket.io-client';
import * as SecureStore from 'expo-secure-store';
import type {
  ClientToServerEvents,
  ServerToClientEvents,
  EncryptedPayload
} from '@draugar/shared';
import { encryptLocation, decryptLocation } from '../../crypto';
import type { Location } from '@draugar/shared';

type DraugarSocket = Socket<ServerToClientEvents, ClientToServerEvents>;

let socket: DraugarSocket | null = null;

// Callbacks for location updates from other family members
type LocationCallback = (userId: string, location: Location) => void;
const locationCallbacks: Set<LocationCallback> = new Set();

export function onFamilyLocationUpdate(callback: LocationCallback): () => void {
  locationCallbacks.add(callback);
  return () => locationCallbacks.delete(callback);
}

export async function connectSocket(serverUrl: string): Promise<boolean> {
  const token = await SecureStore.getItemAsync('draugar_token');
  if (!token) {
    console.error('[socket] No auth token');
    return false;
  }

  socket = io(serverUrl, {
    auth: { token },
    transports: ['websocket', 'polling'],
    reconnection: true,
    reconnectionAttempts: 10,
    reconnectionDelay: 1000,
  });

  socket.on('connect', () => {
    console.log('[socket] Connected');
    socket?.emit('location:subscribe');
  });

  socket.on('disconnect', (reason) => {
    console.log('[socket] Disconnected:', reason);
  });

  socket.on('location:broadcast', async ({ senderId, payload }) => {
    // Decrypt the location from another family member
    const location = await decryptLocation(payload);
    if (location) {
      locationCallbacks.forEach((cb) => cb(senderId, location));
    }
  });

  socket.on('error', (message) => {
    console.error('[socket] Error:', message);
  });

  return true;
}

export async function sendLocationUpdate(location: Location): Promise<void> {
  if (!socket?.connected) {
    console.warn('[socket] Not connected, skipping location update');
    return;
  }

  const encrypted = await encryptLocation(location);
  if (encrypted) {
    socket.emit('location:update', encrypted);
  }
}

export function disconnectSocket(): void {
  if (socket) {
    socket.emit('location:unsubscribe');
    socket.disconnect();
    socket = null;
  }
}

export function isSocketConnected(): boolean {
  return socket?.connected ?? false;
}
```

Note: This requires adding socket.io-client dependency:
```
cd packages/mobile && pnpm add socket.io-client
```
  </action>
  <verify>File exists at packages/mobile/src/services/socket/index.ts with connectSocket, sendLocationUpdate, onFamilyLocationUpdate exports</verify>
  <done>Socket service handles encrypted location send/receive</done>
</task>

<task type="auto">
  <name>Task 4: Create LocationContext for state management</name>
  <files>packages/mobile/src/context/LocationContext.tsx</files>
  <action>
Create LocationContext to manage:
- Location tracking state
- Family member locations
- Integration of location service and socket service

```typescript
import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import type { Location as LocationType } from '@draugar/shared';
import * as Location from 'expo-location';
import {
  startLocationUpdates,
  stopLocationUpdates,
  requestLocationPermissions,
  getLocationPermissionStatus,
  type LocationPermissions
} from '../services/location';
import {
  connectSocket,
  sendLocationUpdate,
  onFamilyLocationUpdate,
  disconnectSocket
} from '../services/socket';
import { useAuth } from './AuthContext';

interface FamilyMember {
  id: string;
  name: string;
  latitude: number;
  longitude: number;
  lastUpdated: Date;
}

interface LocationContextValue {
  isTracking: boolean;
  permissions: LocationPermissions;
  familyLocations: Map<string, FamilyMember>;
  startTracking: () => Promise<boolean>;
  stopTracking: () => Promise<void>;
  requestPermissions: () => Promise<LocationPermissions>;
}

const LocationContext = createContext<LocationContextValue | null>(null);

export function LocationProvider({ children }: { children: React.ReactNode }): React.JSX.Element {
  const { user, isAuthenticated } = useAuth();
  const [isTracking, setIsTracking] = useState(false);
  const [permissions, setPermissions] = useState<LocationPermissions>({ foreground: false, background: false });
  const [familyLocations, setFamilyLocations] = useState<Map<string, FamilyMember>>(new Map());

  // Check permissions on mount
  useEffect(() => {
    getLocationPermissionStatus().then(setPermissions);
  }, []);

  // Connect socket when authenticated
  useEffect(() => {
    if (isAuthenticated) {
      // TODO: Get server URL from config
      const serverUrl = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000';
      connectSocket(serverUrl);

      // Listen for family location updates
      const unsubscribe = onFamilyLocationUpdate((userId, location) => {
        setFamilyLocations((prev) => {
          const next = new Map(prev);
          next.set(userId, {
            id: userId,
            name: userId.slice(0, 8), // TODO: Get actual name from user data
            latitude: location.latitude,
            longitude: location.longitude,
            lastUpdated: new Date(location.timestamp),
          });
          return next;
        });
      });

      return () => {
        unsubscribe();
        disconnectSocket();
      };
    }
  }, [isAuthenticated]);

  const handleLocationUpdate = useCallback(async (locationObj: Location.LocationObject) => {
    if (!user?.id) return;

    const location: LocationType = {
      userId: user.id,
      latitude: locationObj.coords.latitude,
      longitude: locationObj.coords.longitude,
      accuracy: locationObj.coords.accuracy ?? 0,
      timestamp: new Date(locationObj.timestamp),
    };

    await sendLocationUpdate(location);
  }, [user?.id]);

  const startTracking = useCallback(async (): Promise<boolean> => {
    const success = await startLocationUpdates(handleLocationUpdate);
    setIsTracking(success);
    return success;
  }, [handleLocationUpdate]);

  const stopTracking = useCallback(async (): Promise<void> => {
    await stopLocationUpdates();
    setIsTracking(false);
  }, []);

  const requestPermissions = useCallback(async (): Promise<LocationPermissions> => {
    const perms = await requestLocationPermissions();
    setPermissions(perms);
    return perms;
  }, []);

  return (
    <LocationContext.Provider
      value={{
        isTracking,
        permissions,
        familyLocations,
        startTracking,
        stopTracking,
        requestPermissions,
      }}
    >
      {children}
    </LocationContext.Provider>
  );
}

export function useLocation(): LocationContextValue {
  const context = useContext(LocationContext);
  if (!context) {
    throw new Error('useLocation must be used within LocationProvider');
  }
  return context;
}
```
  </action>
  <verify>File exists at packages/mobile/src/context/LocationContext.tsx with LocationProvider and useLocation exports</verify>
  <done>LocationContext manages tracking state and family locations</done>
</task>

<task type="auto">
  <name>Task 5: Update MapScreen to use LocationContext for family markers</name>
  <files>packages/mobile/src/screens/MapScreen.tsx</files>
  <action>
Update MapScreen to:
1. Use useLocation hook for family locations
2. Display family member markers from context
3. Add start/stop tracking button

```typescript
import React from 'react';
import { View, StyleSheet, Text, TouchableOpacity } from 'react-native';
import MapLibreGL from '@maplibre/maplibre-react-native';
import { useLocation } from '../context/LocationContext';

const OPENFREEMAP_STYLE = 'https://tiles.openfreemap.org/styles/liberty/style.json';
MapLibreGL.setAccessToken(null);

export function MapScreen(): React.JSX.Element {
  const { isTracking, familyLocations, startTracking, stopTracking, permissions } = useLocation();

  const handleToggleTracking = async () => {
    if (isTracking) {
      await stopTracking();
    } else {
      await startTracking();
    }
  };

  const familyMembers = Array.from(familyLocations.values());

  return (
    <View style={styles.container}>
      <MapLibreGL.MapView
        style={styles.map}
        styleURL={OPENFREEMAP_STYLE}
        logoEnabled={true}
        attributionEnabled={true}
      >
        <MapLibreGL.Camera
          zoomLevel={14}
          followUserLocation={true}
          followUserMode="normal"
          animationMode="flyTo"
          animationDuration={1000}
        />

        <MapLibreGL.UserLocation
          visible={true}
          animated={true}
          showsUserHeadingIndicator={true}
          minDisplacement={10}
        />

        {familyMembers.map((member) => (
          <MapLibreGL.MarkerView
            key={member.id}
            coordinate={[member.longitude, member.latitude]}
          >
            <View style={styles.marker}>
              <Text style={styles.markerText}>
                {member.name.charAt(0).toUpperCase()}
              </Text>
            </View>
          </MapLibreGL.MarkerView>
        ))}
      </MapLibreGL.MapView>

      <View style={styles.controls}>
        <TouchableOpacity
          style={[styles.button, isTracking && styles.buttonActive]}
          onPress={handleToggleTracking}
        >
          <Text style={styles.buttonText}>
            {isTracking ? 'Stop Sharing' : 'Share Location'}
          </Text>
        </TouchableOpacity>
        {!permissions.background && (
          <Text style={styles.warning}>
            Background location not enabled - sharing stops when app is closed
          </Text>
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1 },
  map: { flex: 1 },
  marker: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#4A90A4',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#fff',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
  },
  markerText: {
    color: '#fff',
    fontWeight: 'bold',
    fontSize: 18,
  },
  controls: {
    position: 'absolute',
    bottom: 40,
    left: 20,
    right: 20,
    alignItems: 'center',
  },
  button: {
    backgroundColor: '#4A90A4',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
  },
  buttonActive: {
    backgroundColor: '#e74c3c',
  },
  buttonText: {
    color: '#fff',
    fontWeight: 'bold',
    fontSize: 16,
  },
  warning: {
    marginTop: 8,
    color: '#e74c3c',
    fontSize: 12,
    textAlign: 'center',
  },
});

export default MapScreen;
```
  </action>
  <verify>grep "useLocation" packages/mobile/src/screens/MapScreen.tsx shows hook usage</verify>
  <done>MapScreen displays family markers from LocationContext with tracking toggle</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>End-to-end encrypted location sharing: mobile broadcasts encrypted location via WebSocket, backend relays to family members, map displays family markers in real-time</what-built>
  <how-to-verify>
NOTE: This requires a development build (not Expo Go) due to MapLibre native code.

1. Build and run development build:
   - cd packages/mobile
   - npx expo run:ios or npx expo run:android

2. Start backend: cd packages/backend && pnpm dev

3. On mobile app:
   - Log in with valid credentials
   - Navigate to Map screen
   - Grant location permissions when prompted (both foreground and background)
   - Tap "Share Location" button

4. Verify:
   - Map displays with OpenStreetMap tiles
   - Blue dot shows your current location
   - No console errors about crypto or socket
   - "Share Location" button turns red when active

5. To test family markers (requires second device/simulator):
   - Log in as different user on second device
   - Both enable location sharing
   - Each should see the other's marker on map

If testing with single device, verify:
   - Console shows "[socket] Connected" and "[ws] Location broadcast from user..."
   - No decryption errors
  </how-to-verify>
  <resume-signal>Type "approved" to complete phase, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] packages/shared/src/types/ws-messages.ts uses EncryptedPayload
- [ ] packages/backend/src/ws/handlers.ts broadcasts to other users
- [ ] packages/mobile/src/services/socket/index.ts handles encrypted send/receive
- [ ] packages/mobile/src/context/LocationContext.tsx manages state
- [ ] packages/mobile/src/screens/MapScreen.tsx uses LocationContext
- [ ] TypeScript compiles in all packages
- [ ] Human verification passed
</verification>

<success_criteria>
- All tasks completed
- Location encrypted before sending
- Server relays without decrypting (zero-knowledge)
- Family markers display on map
- Tracking toggle works
- Human verified the integration
</success_criteria>

<output>
After completion, create `.planning/phases/05-realtime-location/05-04-SUMMARY.md`
</output>
