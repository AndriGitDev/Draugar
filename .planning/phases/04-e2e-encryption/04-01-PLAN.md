---
phase: 04-e2e-encryption
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [packages/shared/src/crypto/types.ts, packages/shared/src/crypto/constants.ts, packages/shared/src/crypto/index.ts, packages/shared/src/index.ts]
autonomous: true
---

<objective>
Create shared cryptographic types and constants for E2E encryption across backend and mobile packages.

Purpose: Establish type-safe contracts for encrypted payloads, keypairs, and crypto operations that will be used consistently across the monorepo.
Output: Shared crypto types exported from @draugar/shared package.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-e2e-encryption/04-RESEARCH.md

@packages/shared/src/index.ts
@packages/shared/src/types/location.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create crypto types</name>
  <files>packages/shared/src/crypto/types.ts</files>
  <action>
Create TypeScript types for E2E encryption:

```typescript
/**
 * Encrypted payload format for location data
 * Uses XChaCha20-Poly1305 authenticated encryption
 */
export interface EncryptedPayload {
  v: 1;           // Version for future compatibility
  n: string;      // Nonce (base64)
  c: string;      // Ciphertext (base64)
}

/**
 * User's encryption keypair (X25519)
 * Public key is shared with server, private key stays on device
 */
export interface CryptoKeyPair {
  publicKey: string;   // Base64-encoded public key
  secretKey: string;   // Base64-encoded secret key (device only)
}

/**
 * Wrapped group key package sent from server to new member
 * Encrypted with member's public key using crypto_box
 */
export interface WrappedGroupKey {
  /** Base64-encoded wrapped key (nonce + encrypted group key) */
  package: string;
  /** Public key of the admin who wrapped this key */
  adminPublicKey: string;
  /** Version of the group key (for rotation tracking) */
  keyVersion: number;
}

/**
 * User's public key registration with server
 */
export interface PublicKeyRegistration {
  userId: string;
  publicKey: string;  // Base64-encoded
}
```

Do NOT include actual crypto implementation - just types. The crypto operations will be platform-specific (libsodium-wrappers on backend, react-native-libsodium on mobile).
  </action>
  <verify>pnpm --filter @draugar/shared run typecheck</verify>
  <done>All crypto types exported and type-checkable</done>
</task>

<task type="auto">
  <name>Task 2: Create crypto constants</name>
  <files>packages/shared/src/crypto/constants.ts</files>
  <action>
Create constants for crypto operations matching libsodium values:

```typescript
/**
 * Crypto constants matching libsodium
 * These are standard sizes, not secrets
 */
export const CRYPTO = {
  // XChaCha20-Poly1305 (location encryption)
  NONCE_BYTES: 24,        // crypto_aead_xchacha20poly1305_ietf_NPUBBYTES
  KEY_BYTES: 32,          // crypto_aead_xchacha20poly1305_ietf_KEYBYTES
  TAG_BYTES: 16,          // Poly1305 auth tag

  // X25519 key exchange (crypto_box)
  BOX_NONCE_BYTES: 24,    // crypto_box_NONCEBYTES
  BOX_PUBLIC_KEY_BYTES: 32,  // crypto_box_PUBLICKEYBYTES
  BOX_SECRET_KEY_BYTES: 32,  // crypto_box_SECRETKEYBYTES
  BOX_MAC_BYTES: 16,      // crypto_box_MACBYTES

  // Key identifiers for SecureStore
  STORAGE_KEYS: {
    PRIVATE_KEY: 'draugar_sk',
    PUBLIC_KEY: 'draugar_pk',
    GROUP_KEY: 'draugar_gk',
  },

  // Current payload version
  PAYLOAD_VERSION: 1,
} as const;
```

These constants ensure consistency between backend and mobile implementations.
  </action>
  <verify>pnpm --filter @draugar/shared run typecheck</verify>
  <done>Constants exported and match libsodium documentation</done>
</task>

<task type="auto">
  <name>Task 3: Export crypto module from shared</name>
  <files>packages/shared/src/crypto/index.ts, packages/shared/src/index.ts</files>
  <action>
Create crypto/index.ts that re-exports types and constants:

```typescript
// packages/shared/src/crypto/index.ts
export type {
  EncryptedPayload,
  CryptoKeyPair,
  WrappedGroupKey,
  PublicKeyRegistration,
} from './types';

export { CRYPTO } from './constants';
```

Update packages/shared/src/index.ts to include crypto exports:

Add after existing exports:
```typescript
// Crypto types
export type {
  EncryptedPayload,
  CryptoKeyPair,
  WrappedGroupKey,
  PublicKeyRegistration,
} from './crypto';

export { CRYPTO } from './crypto';
```

Rebuild shared package after changes.
  </action>
  <verify>cd /root/Draugar && pnpm --filter @draugar/shared run build && pnpm --filter @draugar/backend run typecheck</verify>
  <done>Crypto types importable from @draugar/shared in both backend and mobile</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm --filter @draugar/shared run build` succeeds
- [ ] `pnpm --filter @draugar/backend run typecheck` succeeds (can import types)
- [ ] Types match RESEARCH.md specifications
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Crypto types available for use in subsequent plans
</success_criteria>

<output>
After completion, create `.planning/phases/04-e2e-encryption/04-01-SUMMARY.md`
</output>
