---
phase: 04-e2e-encryption
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified: [packages/backend/src/routes/crypto.ts, packages/backend/src/routes/index.ts, packages/backend/src/index.ts, packages/mobile/src/utils/api.ts, packages/mobile/src/context/AuthContext.tsx]
autonomous: true
---

<objective>
Create API endpoints for public key registration and group key distribution, integrate crypto initialization into app flow.

Purpose: Enable the full key exchange flow - mobile registers public key on auth, receives wrapped group key, stores it for location encryption.
Output: Working E2E key exchange integrated into existing auth flow.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-e2e-encryption/04-RESEARCH.md
@.planning/phases/03-authentication/03-02-SUMMARY.md
@.planning/phases/03-authentication/03-03-SUMMARY.md

@packages/backend/src/routes/auth.ts
@packages/backend/src/routes/index.ts
@packages/mobile/src/context/AuthContext.tsx
@packages/mobile/src/utils/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create crypto API endpoints on backend</name>
  <files>packages/backend/src/routes/crypto.ts, packages/backend/src/routes/index.ts</files>
  <action>
Create packages/backend/src/routes/crypto.ts:

```typescript
import { Router } from 'express';
import type { Request, Response } from 'express';
import type { WrappedGroupKey } from '@draugar/shared';
import { db } from '../db';
import { users, groups } from '../db/schema';
import { eq } from 'drizzle-orm';
import {
  generateGroupKey,
  generateServerKeypair,
  createWrappedGroupKeyPackage,
} from '../crypto';

const router = Router();

/**
 * POST /api/crypto/register-key
 * Register user's public key and return wrapped group key
 *
 * Body: { publicKey: string }
 * Returns: WrappedGroupKey
 *
 * Auth: Requires valid JWT (user must be authenticated)
 */
router.post('/register-key', async (req: Request, res: Response) => {
  try {
    const userId = (req as any).userId; // From auth middleware
    if (!userId) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    const { publicKey } = req.body;
    if (!publicKey || typeof publicKey !== 'string') {
      return res.status(400).json({ error: 'publicKey required' });
    }

    // Validate public key format (base64, correct length ~44 chars for 32 bytes)
    if (publicKey.length < 40 || publicKey.length > 50) {
      return res.status(400).json({ error: 'Invalid public key format' });
    }

    // Store user's public key
    await db
      .update(users)
      .set({ publicKey })
      .where(eq(users.id, userId));

    // Get or create the group (single family group for now)
    let [group] = await db.select().from(groups).limit(1);

    if (!group) {
      // First user - create the group with encryption keys
      const serverKeypair = generateServerKeypair();
      const groupKey = generateGroupKey();

      const [newGroup] = await db
        .insert(groups)
        .values({
          name: 'Family',
          encryptionKey: groupKey,
          keyVersion: 1,
          serverPublicKey: serverKeypair.publicKey,
          serverSecretKey: serverKeypair.secretKey,
        })
        .returning();

      group = newGroup;
    }

    // Wrap the group key for this user
    const wrappedKey: WrappedGroupKey = createWrappedGroupKeyPackage(
      group.encryptionKey,
      publicKey,
      group.serverSecretKey,
      group.serverPublicKey,
      group.keyVersion
    );

    res.json(wrappedKey);
  } catch (error) {
    console.error('Error in register-key:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * GET /api/crypto/group-key
 * Get wrapped group key for authenticated user (for re-fetching after app restart)
 *
 * Returns: WrappedGroupKey or 404 if user hasn't registered public key
 */
router.get('/group-key', async (req: Request, res: Response) => {
  try {
    const userId = (req as any).userId;
    if (!userId) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    // Get user's public key
    const [user] = await db
      .select({ publicKey: users.publicKey })
      .from(users)
      .where(eq(users.id, userId));

    if (!user?.publicKey) {
      return res.status(404).json({ error: 'Public key not registered' });
    }

    // Get the group
    const [group] = await db.select().from(groups).limit(1);

    if (!group) {
      return res.status(404).json({ error: 'No group exists' });
    }

    const wrappedKey: WrappedGroupKey = createWrappedGroupKeyPackage(
      group.encryptionKey,
      user.publicKey,
      group.serverSecretKey,
      group.serverPublicKey,
      group.keyVersion
    );

    res.json(wrappedKey);
  } catch (error) {
    console.error('Error in get-group-key:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

export { router as cryptoRouter };
```

Register the router in packages/backend/src/routes/index.ts:

Add import: `import { cryptoRouter } from './crypto';`
Add route: `router.use('/crypto', requireAuth, cryptoRouter);`

The requireAuth middleware ensures only authenticated users can access crypto endpoints.
  </action>
  <verify>pnpm --filter @draugar/backend run typecheck</verify>
  <done>Crypto API endpoints created and registered</done>
</task>

<task type="auto">
  <name>Task 2: Initialize sodium in backend startup</name>
  <files>packages/backend/src/index.ts</files>
  <action>
Update packages/backend/src/index.ts to initialize sodium before starting the server.

Add near the top (after imports):
```typescript
import { initSodium } from './crypto';
```

In the main startup function, before app.listen():
```typescript
// Initialize crypto library
await initSodium();
console.log('Sodium initialized');
```

This ensures sodium is ready before any crypto endpoints are called.
  </action>
  <verify>pnpm --filter @draugar/backend run typecheck</verify>
  <done>Backend initializes sodium on startup</done>
</task>

<task type="auto">
  <name>Task 3: Integrate key exchange into mobile auth flow</name>
  <files>packages/mobile/src/utils/api.ts, packages/mobile/src/context/AuthContext.tsx</files>
  <action>
Add crypto API functions to packages/mobile/src/utils/api.ts:

```typescript
import type { WrappedGroupKey } from '@draugar/shared';

/**
 * Register public key and get wrapped group key
 */
export async function registerPublicKey(
  publicKey: string
): Promise<WrappedGroupKey> {
  const response = await fetchWithAuth('/api/crypto/register-key', {
    method: 'POST',
    body: JSON.stringify({ publicKey }),
  });
  return response.json();
}

/**
 * Fetch wrapped group key (for re-fetching on app restart)
 */
export async function fetchGroupKey(): Promise<WrappedGroupKey> {
  const response = await fetchWithAuth('/api/crypto/group-key');
  return response.json();
}
```

Update packages/mobile/src/context/AuthContext.tsx to integrate crypto:

1. Import crypto functions at top:
```typescript
import {
  initSodium,
  generateAndStoreKeypair,
  hasKeypair,
  unwrapAndStoreGroupKey,
  getGroupKey,
  clearAllKeys,
} from '../crypto';
import { registerPublicKey, fetchGroupKey } from '../utils/api';
```

2. Add crypto initialization to the auth flow. In the login/join success handler:
```typescript
// After successful auth (token stored):
// Initialize sodium
await initSodium();

// Check if we have a keypair already
if (!(await hasKeypair())) {
  // Generate new keypair
  const publicKey = await generateAndStoreKeypair();
  // Register with server and get wrapped group key
  const wrappedKey = await registerPublicKey(publicKey);
  await unwrapAndStoreGroupKey(wrappedKey);
} else if (!(await getGroupKey())) {
  // Have keypair but no group key - fetch it
  const keypair = await getKeypair();
  if (keypair) {
    const wrappedKey = await fetchGroupKey();
    await unwrapAndStoreGroupKey(wrappedKey);
  }
}
```

3. In logout, clear crypto keys:
```typescript
// In logout function, after clearing token:
await clearAllKeys();
```

4. In the app initialization (checkAuth or useEffect), initialize sodium:
```typescript
// Early in initialization:
await initSodium();
```

Keep the auth flow working - crypto is an addition, not a replacement. Handle crypto errors gracefully (log but don't crash).
  </action>
  <verify>pnpm --filter @draugar/mobile exec tsc --noEmit</verify>
  <done>Mobile auth flow integrates key exchange</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm --filter @draugar/backend run typecheck` succeeds
- [ ] `pnpm --filter @draugar/mobile exec tsc --noEmit` succeeds
- [ ] Crypto routes registered under /api/crypto
- [ ] Auth flow generates keypair on first login
- [ ] Group key received and stored on login
- [ ] Keys cleared on logout
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Full E2E key exchange flow working:
  1. User authenticates
  2. Mobile generates keypair, sends public key
  3. Backend wraps group key with user's public key
  4. Mobile unwraps and stores group key
  5. Mobile ready to encrypt/decrypt locations
</success_criteria>

<output>
After completion, create `.planning/phases/04-e2e-encryption/04-04-SUMMARY.md`
</output>
