---
phase: 04-e2e-encryption
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified: [packages/backend/package.json, packages/backend/src/crypto/sodium.ts, packages/backend/src/crypto/groupKey.ts, packages/backend/src/crypto/index.ts, packages/backend/src/db/schema.ts]
autonomous: true
---

<objective>
Set up libsodium on backend with group key generation and key wrapping functions.

Purpose: Enable server-side cryptographic operations for group key management while maintaining zero-knowledge (server generates/distributes encrypted keys but cannot read user data).
Output: Backend crypto module with group key operations and database schema for storing wrapped keys.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-e2e-encryption/04-RESEARCH.md

@packages/backend/package.json
@packages/backend/src/db/schema.ts
@packages/shared/src/crypto/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install libsodium-wrappers on backend</name>
  <files>packages/backend/package.json</files>
  <action>
Install libsodium-wrappers and its types:

```bash
cd /root/Draugar
pnpm --filter @draugar/backend add libsodium-wrappers
pnpm --filter @draugar/backend add -D @types/libsodium-wrappers
```

This is the WebAssembly-based libsodium for Node.js, ~188KB including pure JS fallback.
  </action>
  <verify>grep "libsodium-wrappers" packages/backend/package.json</verify>
  <done>libsodium-wrappers installed with types</done>
</task>

<task type="auto">
  <name>Task 2: Create sodium initialization and crypto utilities</name>
  <files>packages/backend/src/crypto/sodium.ts, packages/backend/src/crypto/groupKey.ts, packages/backend/src/crypto/index.ts</files>
  <action>
Create packages/backend/src/crypto/sodium.ts for initialization:

```typescript
import sodium from 'libsodium-wrappers';

let initialized = false;

/**
 * Initialize libsodium. Must be called before any crypto operations.
 * Safe to call multiple times - will only initialize once.
 */
export async function initSodium(): Promise<typeof sodium> {
  if (!initialized) {
    await sodium.ready;
    initialized = true;
  }
  return sodium;
}

/**
 * Get initialized sodium instance.
 * Throws if called before initSodium().
 */
export function getSodium(): typeof sodium {
  if (!initialized) {
    throw new Error('Sodium not initialized. Call initSodium() first.');
  }
  return sodium;
}
```

Create packages/backend/src/crypto/groupKey.ts for group key operations:

```typescript
import type { WrappedGroupKey } from '@draugar/shared';
import { getSodium } from './sodium';

/**
 * Generate a new group encryption key.
 * Uses crypto_aead_xchacha20poly1305_ietf_keygen internally.
 * @returns Base64-encoded 32-byte key
 */
export function generateGroupKey(): string {
  const sodium = getSodium();
  const key = sodium.crypto_aead_xchacha20poly1305_ietf_keygen();
  return sodium.to_base64(key);
}

/**
 * Generate a keypair for the server/admin.
 * Used for wrapping group keys for new members.
 */
export function generateServerKeypair(): { publicKey: string; secretKey: string } {
  const sodium = getSodium();
  const keypair = sodium.crypto_box_keypair();
  return {
    publicKey: sodium.to_base64(keypair.publicKey),
    secretKey: sodium.to_base64(keypair.privateKey),
  };
}

/**
 * Wrap a group key for a specific member using their public key.
 * @param groupKey - Base64-encoded group key
 * @param memberPublicKey - Base64-encoded member's public key
 * @param serverSecretKey - Base64-encoded server's secret key
 * @returns Wrapped key package (nonce + encrypted key as base64)
 */
export function wrapGroupKeyForMember(
  groupKey: string,
  memberPublicKey: string,
  serverSecretKey: string
): string {
  const sodium = getSodium();

  const groupKeyBytes = sodium.from_base64(groupKey);
  const memberPkBytes = sodium.from_base64(memberPublicKey);
  const serverSkBytes = sodium.from_base64(serverSecretKey);

  const nonce = sodium.randombytes_buf(sodium.crypto_box_NONCEBYTES);
  const encrypted = sodium.crypto_box_easy(
    groupKeyBytes,
    nonce,
    memberPkBytes,
    serverSkBytes
  );

  // Combine nonce + encrypted for transmission
  const combined = new Uint8Array(nonce.length + encrypted.length);
  combined.set(nonce);
  combined.set(encrypted, nonce.length);

  return sodium.to_base64(combined);
}

/**
 * Create a complete wrapped group key package for a member.
 */
export function createWrappedGroupKeyPackage(
  groupKey: string,
  memberPublicKey: string,
  serverSecretKey: string,
  serverPublicKey: string,
  keyVersion: number
): WrappedGroupKey {
  return {
    package: wrapGroupKeyForMember(groupKey, memberPublicKey, serverSecretKey),
    adminPublicKey: serverPublicKey,
    keyVersion,
  };
}
```

Create packages/backend/src/crypto/index.ts:

```typescript
export { initSodium, getSodium } from './sodium';
export {
  generateGroupKey,
  generateServerKeypair,
  wrapGroupKeyForMember,
  createWrappedGroupKeyPackage,
} from './groupKey';
```

CRITICAL: Always use sodium.randombytes_buf() for nonces, never Math.random() or static values.
  </action>
  <verify>pnpm --filter @draugar/backend run typecheck</verify>
  <done>Backend crypto module with group key operations ready</done>
</task>

<task type="auto">
  <name>Task 3: Add crypto columns to database schema</name>
  <files>packages/backend/src/db/schema.ts</files>
  <action>
Update the database schema to store:
1. User's public key (for key wrapping)
2. Group's encryption key (encrypted at rest ideally, but for v1 stored as-is)
3. Server keypair for key wrapping operations

Add to users table:
```typescript
publicKey: text('public_key'),  // Base64-encoded X25519 public key, nullable until registered
```

Create new groups table (or add to existing if there's a family/group concept):
```typescript
export const groups = pgTable('groups', {
  id: uuid('id').primaryKey().defaultRandom(),
  name: text('name').notNull(),
  encryptionKey: text('encryption_key').notNull(),  // Base64-encoded group key
  keyVersion: integer('key_version').notNull().default(1),
  serverPublicKey: text('server_public_key').notNull(),  // For key wrapping
  serverSecretKey: text('server_secret_key').notNull(),  // Keep secure!
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow(),
});
```

Note: In production, server_secret_key should be in a secrets manager, but for family app v1, database storage is acceptable.

If users table doesn't exist yet, reference existing schema patterns from 02-01-SUMMARY or check current schema.
  </action>
  <verify>pnpm --filter @draugar/backend run typecheck</verify>
  <done>Database schema updated with crypto-related columns</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm --filter @draugar/backend run typecheck` succeeds
- [ ] `libsodium-wrappers` in package.json dependencies
- [ ] Backend crypto module exports all functions
- [ ] Database schema has publicKey on users, groups table with crypto fields
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Group key generation and wrapping functions ready for API use
</success_criteria>

<output>
After completion, create `.planning/phases/04-e2e-encryption/04-02-SUMMARY.md`
</output>
