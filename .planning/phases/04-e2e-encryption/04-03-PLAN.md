---
phase: 04-e2e-encryption
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified: [packages/mobile/package.json, packages/mobile/app.config.js, packages/mobile/src/crypto/sodium.ts, packages/mobile/src/crypto/keyStore.ts, packages/mobile/src/crypto/location.ts, packages/mobile/src/crypto/index.ts]
autonomous: true
---

<objective>
Set up react-native-libsodium on mobile with keypair generation, secure storage, and location encryption functions.

Purpose: Enable client-side cryptographic operations - keys stay on device, location data encrypted before transmission.
Output: Mobile crypto module with keypair management, secure storage, and location encrypt/decrypt functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-e2e-encryption/04-RESEARCH.md

@packages/mobile/package.json
@packages/mobile/src/utils/storage.ts
@packages/shared/src/crypto/types.ts
@packages/shared/src/types/location.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-native-libsodium with Expo plugin</name>
  <files>packages/mobile/package.json, packages/mobile/app.config.js</files>
  <action>
Install react-native-libsodium:

```bash
cd /root/Draugar
pnpm --filter @draugar/mobile add react-native-libsodium
```

Update app.config.js (or create if using app.json) to add the Expo plugin:

Check if app.config.js exists. If using app.json, convert to app.config.js or add plugins array.

Add to plugins array:
```javascript
plugins: [
  // ... existing plugins
  ["react-native-libsodium", {}]
]
```

This enables the native bindings required for react-native-libsodium to work on iOS/Android.

Note: expo-secure-store is already installed from Phase 3 (03-03).
  </action>
  <verify>grep "react-native-libsodium" packages/mobile/package.json</verify>
  <done>react-native-libsodium installed with Expo plugin configured</done>
</task>

<task type="auto">
  <name>Task 2: Create sodium initialization and key store</name>
  <files>packages/mobile/src/crypto/sodium.ts, packages/mobile/src/crypto/keyStore.ts</files>
  <action>
Create packages/mobile/src/crypto/sodium.ts:

```typescript
import sodium from 'react-native-libsodium';

let initialized = false;

/**
 * Initialize libsodium. Must be called before any crypto operations.
 * Safe to call multiple times - will only initialize once.
 */
export async function initSodium(): Promise<typeof sodium> {
  if (!initialized) {
    await sodium.ready;
    initialized = true;
  }
  return sodium;
}

/**
 * Get initialized sodium instance.
 * Throws if called before initSodium().
 */
export function getSodium(): typeof sodium {
  if (!initialized) {
    throw new Error('Sodium not initialized. Call initSodium() first.');
  }
  return sodium;
}
```

Create packages/mobile/src/crypto/keyStore.ts:

```typescript
import * as SecureStore from 'expo-secure-store';
import type { CryptoKeyPair, WrappedGroupKey } from '@draugar/shared';
import { CRYPTO } from '@draugar/shared';
import { getSodium } from './sodium';

const { STORAGE_KEYS } = CRYPTO;

/**
 * Generate a new X25519 keypair and store securely.
 * @returns The public key (base64) for registration with server
 */
export async function generateAndStoreKeypair(): Promise<string> {
  const sodium = getSodium();
  const keypair = sodium.crypto_box_keypair();

  const publicKeyB64 = sodium.to_base64(keypair.publicKey);
  const secretKeyB64 = sodium.to_base64(keypair.privateKey);

  await Promise.all([
    SecureStore.setItemAsync(STORAGE_KEYS.PUBLIC_KEY, publicKeyB64),
    SecureStore.setItemAsync(STORAGE_KEYS.PRIVATE_KEY, secretKeyB64),
  ]);

  return publicKeyB64;
}

/**
 * Get the stored keypair.
 * @returns CryptoKeyPair or null if not generated yet
 */
export async function getKeypair(): Promise<CryptoKeyPair | null> {
  const [publicKey, secretKey] = await Promise.all([
    SecureStore.getItemAsync(STORAGE_KEYS.PUBLIC_KEY),
    SecureStore.getItemAsync(STORAGE_KEYS.PRIVATE_KEY),
  ]);

  if (!publicKey || !secretKey) {
    return null;
  }

  return { publicKey, secretKey };
}

/**
 * Check if a keypair exists in secure storage.
 */
export async function hasKeypair(): Promise<boolean> {
  const pk = await SecureStore.getItemAsync(STORAGE_KEYS.PUBLIC_KEY);
  return pk !== null;
}

/**
 * Unwrap a group key package received from server.
 * @param wrappedKey - The wrapped key package from server
 * @returns Base64-encoded group key, or null if unwrapping fails
 */
export async function unwrapAndStoreGroupKey(
  wrappedKey: WrappedGroupKey
): Promise<boolean> {
  const sodium = getSodium();
  const keypair = await getKeypair();

  if (!keypair) {
    console.error('No keypair available to unwrap group key');
    return false;
  }

  try {
    const combined = sodium.from_base64(wrappedKey.package);
    const adminPk = sodium.from_base64(wrappedKey.adminPublicKey);
    const secretKey = sodium.from_base64(keypair.secretKey);

    // Extract nonce (first 24 bytes) and encrypted key
    const nonce = combined.slice(0, sodium.crypto_box_NONCEBYTES);
    const encrypted = combined.slice(sodium.crypto_box_NONCEBYTES);

    const groupKeyBytes = sodium.crypto_box_open_easy(
      encrypted,
      nonce,
      adminPk,
      secretKey
    );

    const groupKeyB64 = sodium.to_base64(groupKeyBytes);
    await SecureStore.setItemAsync(STORAGE_KEYS.GROUP_KEY, groupKeyB64);

    return true;
  } catch (error) {
    console.error('Failed to unwrap group key:', error);
    return false;
  }
}

/**
 * Get the stored group key.
 * @returns Base64-encoded group key or null
 */
export async function getGroupKey(): Promise<string | null> {
  return SecureStore.getItemAsync(STORAGE_KEYS.GROUP_KEY);
}

/**
 * Clear all crypto keys (for logout/reset).
 */
export async function clearAllKeys(): Promise<void> {
  await Promise.all([
    SecureStore.deleteItemAsync(STORAGE_KEYS.PUBLIC_KEY),
    SecureStore.deleteItemAsync(STORAGE_KEYS.PRIVATE_KEY),
    SecureStore.deleteItemAsync(STORAGE_KEYS.GROUP_KEY),
  ]);
}
```

CRITICAL:
- Only store keys in SecureStore, NEVER in AsyncStorage
- Private key must NEVER be sent to server
- Always handle decryption failures gracefully
  </action>
  <verify>pnpm --filter @draugar/mobile exec tsc --noEmit</verify>
  <done>Keypair generation and secure storage working</done>
</task>

<task type="auto">
  <name>Task 3: Create location encryption/decryption functions</name>
  <files>packages/mobile/src/crypto/location.ts, packages/mobile/src/crypto/index.ts</files>
  <action>
Create packages/mobile/src/crypto/location.ts:

```typescript
import type { Location, EncryptedPayload } from '@draugar/shared';
import { CRYPTO } from '@draugar/shared';
import { getSodium } from './sodium';
import { getGroupKey } from './keyStore';

/**
 * Encrypt a location update before sending to server.
 * @param location - The location data to encrypt
 * @returns EncryptedPayload ready for transmission, or null if no group key
 */
export async function encryptLocation(
  location: Location
): Promise<EncryptedPayload | null> {
  const groupKeyB64 = await getGroupKey();
  if (!groupKeyB64) {
    console.error('No group key available for encryption');
    return null;
  }

  const sodium = getSodium();
  const groupKey = sodium.from_base64(groupKeyB64);

  // Serialize location to JSON bytes
  const plaintext = new TextEncoder().encode(JSON.stringify(location));

  // Generate random nonce (24 bytes for XChaCha20-Poly1305)
  const nonce = sodium.randombytes_buf(
    sodium.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES
  );

  // Encrypt with authenticated encryption
  const ciphertext = sodium.crypto_aead_xchacha20poly1305_ietf_encrypt(
    plaintext,
    null, // no additional authenticated data
    null, // unused parameter (secret nonce)
    nonce,
    groupKey
  );

  return {
    v: CRYPTO.PAYLOAD_VERSION,
    n: sodium.to_base64(nonce),
    c: sodium.to_base64(ciphertext),
  };
}

/**
 * Decrypt a location update received from server (via WebSocket).
 * @param payload - The encrypted payload
 * @returns Decrypted Location or null if decryption fails
 */
export async function decryptLocation(
  payload: EncryptedPayload
): Promise<Location | null> {
  const groupKeyB64 = await getGroupKey();
  if (!groupKeyB64) {
    console.error('No group key available for decryption');
    return null;
  }

  const sodium = getSodium();

  try {
    const groupKey = sodium.from_base64(groupKeyB64);
    const nonce = sodium.from_base64(payload.n);
    const ciphertext = sodium.from_base64(payload.c);

    const plaintext = sodium.crypto_aead_xchacha20poly1305_ietf_decrypt(
      null, // unused parameter (secret nonce)
      ciphertext,
      null, // no additional authenticated data
      nonce,
      groupKey
    );

    const location = JSON.parse(
      new TextDecoder().decode(plaintext)
    ) as Location;

    return location;
  } catch (error) {
    // Decryption failure could mean:
    // - Tampered data
    // - Wrong group key version
    // - Corrupted transmission
    console.error('Location decryption failed:', error);
    return null;
  }
}
```

Create packages/mobile/src/crypto/index.ts:

```typescript
export { initSodium, getSodium } from './sodium';
export {
  generateAndStoreKeypair,
  getKeypair,
  hasKeypair,
  unwrapAndStoreGroupKey,
  getGroupKey,
  clearAllKeys,
} from './keyStore';
export { encryptLocation, decryptLocation } from './location';
```

CRITICAL:
- Always use random nonces via randombytes_buf(), never static or Math.random()
- Always wrap decryption in try/catch and return null on failure
- Never log or expose the actual key material
  </action>
  <verify>pnpm --filter @draugar/mobile exec tsc --noEmit</verify>
  <done>Location encryption/decryption ready for use with WebSocket</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm --filter @draugar/mobile exec tsc --noEmit` succeeds
- [ ] `react-native-libsodium` in package.json dependencies
- [ ] Expo plugin configured in app.config.js
- [ ] All crypto functions exported from crypto/index.ts
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Mobile can generate keypairs, store securely, and encrypt/decrypt locations
</success_criteria>

<output>
After completion, create `.planning/phases/04-e2e-encryption/04-03-SUMMARY.md`
</output>
